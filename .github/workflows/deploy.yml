# TruePulse Deployment Pipeline
# Two-phase deployment: shared resources then environment-specific resources
# Only runs after CI workflow succeeds

name: Deploy

on:
  workflow_run:
    workflows: [CI]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

permissions:
  id-token: write
  contents: read

env:
  AZURE_LOCATION: eastus2

jobs:
  # ============================================================================
  # Verify CI Success (for workflow_run trigger)
  # ============================================================================
  check-ci:
    name: Verify CI Passed
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    steps:
      - run: echo "CI workflow succeeded, proceeding with deployment"

  # ============================================================================
  # Determine Environment
  # ============================================================================
  setup:
    name: Setup
    runs-on: ubuntu-latest
    needs: check-ci
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    steps:
      - name: Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Deploy Shared Resources (ACR, Communication Services, Log Analytics, DNS)
  # Always runs - Azure deployments are idempotent
  # ============================================================================
  shared-infrastructure:
    name: Deploy Shared Resources
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      # Pass name instead of full ID to avoid GitHub secret masking (subscription ID triggers it)
      logAnalyticsWorkspaceName: ${{ steps.deploy-shared.outputs.logAnalyticsWorkspaceName }}
      containerRegistryName: ${{ steps.deploy-shared.outputs.containerRegistryName }}
      containerRegistryLoginServer: ${{ steps.deploy-shared.outputs.containerRegistryLoginServer }}
      communicationServiceName: ${{ steps.deploy-shared.outputs.communicationServiceName }}
      communicationServiceConnectionString: ${{ steps.deploy-shared.outputs.communicationServiceConnectionString }}
      # DNS zone names (IDs are reconstructed in infrastructure job to avoid masking)
      blobDnsZoneName: ${{ steps.deploy-shared.outputs.blobDnsZoneName }}
      tableDnsZoneName: ${{ steps.deploy-shared.outputs.tableDnsZoneName }}
      openaiDnsZoneName: ${{ steps.deploy-shared.outputs.openaiDnsZoneName }}
      postgresDnsZoneName: ${{ steps.deploy-shared.outputs.postgresDnsZoneName }}
      keyVaultDnsZoneName: ${{ steps.deploy-shared.outputs.keyVaultDnsZoneName }}
      acrDnsZoneName: ${{ steps.deploy-shared.outputs.acrDnsZoneName }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy Shared Bicep
        id: deploy-shared
        run: |
          echo "Deploying shared resources..."
          
          # Deploy and save outputs to a temp file (more reliable than variable capture)
          az deployment sub create \
            --name "shared-$(date +%Y%m%d%H%M%S)" \
            --location ${{ env.AZURE_LOCATION }} \
            --template-file infra/shared.bicep \
            --parameters location=${{ env.AZURE_LOCATION }} \
            --query 'properties.outputs' \
            --output json > /tmp/deployment-outputs.json
          
          echo "Deployment outputs saved to file:"
          cat /tmp/deployment-outputs.json
          
          # Extract values from deployment outputs file
          # Use workspace NAME instead of ID to avoid GitHub secret masking
          LOG_ANALYTICS_NAME=$(jq -r '.logAnalyticsWorkspaceName.value' /tmp/deployment-outputs.json)
          ACR_NAME=$(jq -r '.containerRegistryName.value' /tmp/deployment-outputs.json)
          ACR_LOGIN=$(jq -r '.containerRegistryLoginServer.value' /tmp/deployment-outputs.json)
          ACS_NAME=$(jq -r '.communicationServiceName.value' /tmp/deployment-outputs.json)
          
          # DNS zone IDs - extract just the zone names (last segment of the ID path)
          BLOB_DNS_ID=$(jq -r '.blobDnsZoneId.value' /tmp/deployment-outputs.json)
          TABLE_DNS_ID=$(jq -r '.tableDnsZoneId.value' /tmp/deployment-outputs.json)
          OPENAI_DNS_ID=$(jq -r '.openaiDnsZoneId.value' /tmp/deployment-outputs.json)
          POSTGRES_DNS_ID=$(jq -r '.postgresDnsZoneId.value' /tmp/deployment-outputs.json)
          KEYVAULT_DNS_ID=$(jq -r '.keyVaultDnsZoneId.value' /tmp/deployment-outputs.json)
          ACR_DNS_ID=$(jq -r '.acrDnsZoneId.value' /tmp/deployment-outputs.json)
          
          # Extract zone names from IDs (e.g., ".../privateDnsZones/privatelink.blob.core.windows.net")
          BLOB_DNS_NAME=$(basename "$BLOB_DNS_ID")
          TABLE_DNS_NAME=$(basename "$TABLE_DNS_ID")
          OPENAI_DNS_NAME=$(basename "$OPENAI_DNS_ID")
          POSTGRES_DNS_NAME=$(basename "$POSTGRES_DNS_ID")
          KEYVAULT_DNS_NAME=$(basename "$KEYVAULT_DNS_ID")
          ACR_DNS_NAME=$(basename "$ACR_DNS_ID")
          
          echo "=== Extracted Values ==="
          echo "Log Analytics Name: [$LOG_ANALYTICS_NAME]"
          echo "ACR Name: [$ACR_NAME]"
          echo "ACR Login: [$ACR_LOGIN]"
          echo "ACS Name: [$ACS_NAME]"
          echo "Blob DNS Zone: [$BLOB_DNS_NAME]"
          echo "Table DNS Zone: [$TABLE_DNS_NAME]"
          echo "OpenAI DNS Zone: [$OPENAI_DNS_NAME]"
          echo "Postgres DNS Zone: [$POSTGRES_DNS_NAME]"
          echo "KeyVault DNS Zone: [$KEYVAULT_DNS_NAME]"
          echo "ACR DNS Zone: [$ACR_DNS_NAME]"
          echo "========================="
          
          # Validate Log Analytics Name
          if [ -z "$LOG_ANALYTICS_NAME" ] || [ "$LOG_ANALYTICS_NAME" == "null" ]; then
            echo "ERROR: Failed to get Log Analytics Workspace Name from deployment outputs!"
            exit 1
          fi
          
          # Write outputs (name, not ID - to avoid secret masking)
          echo "logAnalyticsWorkspaceName=$LOG_ANALYTICS_NAME" >> $GITHUB_OUTPUT
          echo "containerRegistryName=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "containerRegistryLoginServer=$ACR_LOGIN" >> $GITHUB_OUTPUT
          echo "communicationServiceName=$ACS_NAME" >> $GITHUB_OUTPUT
          
          # DNS zone names (IDs will be reconstructed in infrastructure job)
          echo "blobDnsZoneName=$BLOB_DNS_NAME" >> $GITHUB_OUTPUT
          echo "tableDnsZoneName=$TABLE_DNS_NAME" >> $GITHUB_OUTPUT
          echo "openaiDnsZoneName=$OPENAI_DNS_NAME" >> $GITHUB_OUTPUT
          echo "postgresDnsZoneName=$POSTGRES_DNS_NAME" >> $GITHUB_OUTPUT
          echo "keyVaultDnsZoneName=$KEYVAULT_DNS_NAME" >> $GITHUB_OUTPUT
          echo "acrDnsZoneName=$ACR_DNS_NAME" >> $GITHUB_OUTPUT
          
          # Get Communication Service connection string (not in Bicep outputs)
          ACS_CONN=$(az communication list-key --name "$ACS_NAME" --resource-group rg-truepulse-shared --query 'primaryConnectionString' -o tsv)
          echo "communicationServiceConnectionString=$ACS_CONN" >> $GITHUB_OUTPUT
          
          echo "=== GITHUB_OUTPUT contents ==="
          cat $GITHUB_OUTPUT
          echo "==============================="

  # ============================================================================
  # Deploy Environment Infrastructure
  # ============================================================================
  infrastructure:
    name: Deploy ${{ needs.setup.outputs.environment }} Infrastructure
    runs-on: ubuntu-latest
    needs: [setup, shared-infrastructure]
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      resourceGroupName: ${{ steps.deploy.outputs.resourceGroupName }}
      acrLoginServer: ${{ steps.deploy.outputs.acrLoginServer }}
      apiFqdn: ${{ steps.deploy.outputs.apiFqdn }}
      swaHostname: ${{ steps.deploy.outputs.swaHostname }}
      keyVaultUri: ${{ steps.deploy.outputs.keyVaultUri }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Display Shared Resource Values
        id: shared
        run: |
          # Use outputs from shared-infrastructure job
          # NOTE: We get workspace NAME (not ID) to avoid GitHub secret masking
          # The full resource ID contains the subscription ID which GitHub treats as sensitive
          LOG_ANALYTICS_NAME="${{ needs.shared-infrastructure.outputs.logAnalyticsWorkspaceName }}"
          ACR_NAME="${{ needs.shared-infrastructure.outputs.containerRegistryName }}"
          ACR_LOGIN="${{ needs.shared-infrastructure.outputs.containerRegistryLoginServer }}"
          ACS_NAME="${{ needs.shared-infrastructure.outputs.communicationServiceName }}"
          ACS_CONN="${{ needs.shared-infrastructure.outputs.communicationServiceConnectionString }}"
          
          # DNS zone names
          BLOB_DNS_NAME="${{ needs.shared-infrastructure.outputs.blobDnsZoneName }}"
          TABLE_DNS_NAME="${{ needs.shared-infrastructure.outputs.tableDnsZoneName }}"
          OPENAI_DNS_NAME="${{ needs.shared-infrastructure.outputs.openaiDnsZoneName }}"
          POSTGRES_DNS_NAME="${{ needs.shared-infrastructure.outputs.postgresDnsZoneName }}"
          KEYVAULT_DNS_NAME="${{ needs.shared-infrastructure.outputs.keyVaultDnsZoneName }}"
          ACR_DNS_NAME="${{ needs.shared-infrastructure.outputs.acrDnsZoneName }}"
          
          # Reconstruct full resource IDs from names (avoids GitHub secret masking)
          LOG_ANALYTICS_ID="/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/rg-truepulse-shared/providers/Microsoft.OperationalInsights/workspaces/${LOG_ANALYTICS_NAME}"
          ACR_RESOURCE_ID="/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/rg-truepulse-shared/providers/Microsoft.ContainerRegistry/registries/${ACR_NAME}"
          BLOB_DNS_ID="/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/rg-truepulse-shared/providers/Microsoft.Network/privateDnsZones/${BLOB_DNS_NAME}"
          TABLE_DNS_ID="/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/rg-truepulse-shared/providers/Microsoft.Network/privateDnsZones/${TABLE_DNS_NAME}"
          OPENAI_DNS_ID="/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/rg-truepulse-shared/providers/Microsoft.Network/privateDnsZones/${OPENAI_DNS_NAME}"
          POSTGRES_DNS_ID="/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/rg-truepulse-shared/providers/Microsoft.Network/privateDnsZones/${POSTGRES_DNS_NAME}"
          KEYVAULT_DNS_ID="/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/rg-truepulse-shared/providers/Microsoft.Network/privateDnsZones/${KEYVAULT_DNS_NAME}"
          ACR_DNS_ID="/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/rg-truepulse-shared/providers/Microsoft.Network/privateDnsZones/${ACR_DNS_NAME}"
          
          # Debug output
          echo "=== Shared Resource Values ==="
          echo "Log Analytics Name: $LOG_ANALYTICS_NAME"
          echo "ACR Name: $ACR_NAME"
          echo "ACR Login: $ACR_LOGIN"
          echo "ACS Name: $ACS_NAME"
          echo "DNS Zones: blob=$BLOB_DNS_NAME table=$TABLE_DNS_NAME openai=$OPENAI_DNS_NAME postgres=$POSTGRES_DNS_NAME keyvault=$KEYVAULT_DNS_NAME acr=$ACR_DNS_NAME"
          echo "==============================="
          
          # Validate required values
          if [ -z "$LOG_ANALYTICS_NAME" ]; then
            echo "ERROR: Log Analytics Workspace Name is empty!"
            exit 1
          fi
          
          # Write step outputs
          echo "logAnalyticsWorkspaceId=$LOG_ANALYTICS_ID" >> $GITHUB_OUTPUT
          echo "containerRegistryName=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "containerRegistryLoginServer=$ACR_LOGIN" >> $GITHUB_OUTPUT
          echo "containerRegistryResourceId=$ACR_RESOURCE_ID" >> $GITHUB_OUTPUT
          echo "communicationServiceName=$ACS_NAME" >> $GITHUB_OUTPUT
          echo "communicationServiceConnectionString=$ACS_CONN" >> $GITHUB_OUTPUT
          echo "blobDnsZoneId=$BLOB_DNS_ID" >> $GITHUB_OUTPUT
          echo "tableDnsZoneId=$TABLE_DNS_ID" >> $GITHUB_OUTPUT
          echo "openaiDnsZoneId=$OPENAI_DNS_ID" >> $GITHUB_OUTPUT
          echo "postgresDnsZoneId=$POSTGRES_DNS_ID" >> $GITHUB_OUTPUT
          echo "keyVaultDnsZoneId=$KEYVAULT_DNS_ID" >> $GITHUB_OUTPUT
          echo "acrDnsZoneId=$ACR_DNS_ID" >> $GITHUB_OUTPUT

      - name: Deploy Environment Bicep
        id: deploy
        run: |
          echo "Deploying ${{ needs.setup.outputs.environment }} environment..."
          echo "Using Log Analytics: ${{ steps.shared.outputs.logAnalyticsWorkspaceId }}"
          
          DEPLOYMENT_OUTPUT=$(az deployment sub create \
            --name "${{ needs.setup.outputs.environment }}-$(date +%Y%m%d%H%M%S)" \
            --location ${{ env.AZURE_LOCATION }} \
            --template-file infra/main.bicep \
            --parameters environmentName=${{ needs.setup.outputs.environment }} \
            --parameters location=${{ env.AZURE_LOCATION }} \
            --parameters postgresAdminUsername='truepulseadmin' \
            --parameters postgresAdminPassword='${{ secrets.POSTGRES_PASSWORD }}' \
            --parameters jwtSecretKey='${{ secrets.JWT_SECRET_KEY }}' \
            --parameters voteHashSecret='${{ secrets.VOTE_HASH_SECRET }}' \
            --parameters newsDataApiKey='${{ secrets.NEWSDATA_API_KEY }}' \
            --parameters newsApiOrgKey='${{ secrets.NEWSAPI_ORG_KEY }}' \
            --parameters communicationSenderNumber='${{ secrets.COMMUNICATION_SENDER_NUMBER }}' \
            --parameters enableCMK=false \
            --parameters enableCustomDomain=false \
            --parameters sharedLogAnalyticsWorkspaceId='${{ steps.shared.outputs.logAnalyticsWorkspaceId }}' \
            --parameters sharedContainerRegistryName='${{ steps.shared.outputs.containerRegistryName }}' \
            --parameters sharedContainerRegistryLoginServer='${{ steps.shared.outputs.containerRegistryLoginServer }}' \
            --parameters sharedCommunicationServiceConnectionString='${{ steps.shared.outputs.communicationServiceConnectionString }}' \
            --parameters sharedCommunicationServiceName='${{ steps.shared.outputs.communicationServiceName }}' \
            --parameters sharedBlobDnsZoneId='${{ steps.shared.outputs.blobDnsZoneId }}' \
            --parameters sharedTableDnsZoneId='${{ steps.shared.outputs.tableDnsZoneId }}' \
            --parameters sharedOpenaiDnsZoneId='${{ steps.shared.outputs.openaiDnsZoneId }}' \
            --parameters sharedPostgresDnsZoneId='${{ steps.shared.outputs.postgresDnsZoneId }}' \
            --parameters sharedKeyVaultDnsZoneId='${{ steps.shared.outputs.keyVaultDnsZoneId }}' \
            --parameters sharedAcrDnsZoneId='${{ steps.shared.outputs.acrDnsZoneId }}' \
            --parameters sharedContainerRegistryResourceId='${{ steps.shared.outputs.containerRegistryResourceId }}' \
            --query 'properties.outputs' \
            --output json)
          
          echo "resourceGroupName=$(echo $DEPLOYMENT_OUTPUT | jq -r '.resourceGroupName.value')" >> $GITHUB_OUTPUT
          echo "acrLoginServer=${{ steps.shared.outputs.containerRegistryLoginServer }}" >> $GITHUB_OUTPUT
          echo "apiFqdn=$(echo $DEPLOYMENT_OUTPUT | jq -r '.containerAppApiFqdn.value')" >> $GITHUB_OUTPUT
          echo "swaHostname=$(echo $DEPLOYMENT_OUTPUT | jq -r '.staticWebAppHostname.value')" >> $GITHUB_OUTPUT
          echo "keyVaultUri=$(echo $DEPLOYMENT_OUTPUT | jq -r '.keyVaultUri.value')" >> $GITHUB_OUTPUT

      - name: Save SWA Deployment Token to Key Vault
        run: |
          # Get the SWA deployment token
          SWA_NAME=$(az resource list \
            --resource-group ${{ steps.deploy.outputs.resourceGroupName }} \
            --resource-type Microsoft.Web/staticSites \
            --query '[0].name' -o tsv)
          
          SWA_TOKEN=$(az staticwebapp secrets list \
            --name $SWA_NAME \
            --resource-group ${{ steps.deploy.outputs.resourceGroupName }} \
            --query 'properties.apiKey' -o tsv)
          
          # Store in Key Vault
          KV_NAME=$(az keyvault list \
            --resource-group ${{ steps.deploy.outputs.resourceGroupName }} \
            --query '[0].name' -o tsv)
          
          az keyvault secret set \
            --vault-name $KV_NAME \
            --name swa-deployment-token \
            --value "$SWA_TOKEN" || true

  # ============================================================================
  # Build and Push Backend Container
  # ============================================================================
  build-backend:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: [setup, infrastructure]
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      imageTag: ${{ steps.meta.outputs.tags }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: |
          az acr login --name ${{ needs.infrastructure.outputs.acrLoginServer }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.infrastructure.outputs.acrLoginServer }}/truepulse-api
          tags: |
            type=sha,prefix=
            type=raw,value=${{ needs.setup.outputs.environment }}
            type=raw,value=latest,enable=${{ needs.setup.outputs.environment == 'prod' }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: src/backend
          file: src/backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false  # Disable provenance attestation to avoid ACR push issues
          build-args: |
            ENVIRONMENT=${{ needs.setup.outputs.environment }}

  # ============================================================================
  # Deploy Backend to Container Apps
  # ============================================================================
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [setup, infrastructure, build-backend]
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy to Container Apps
        run: |
          IMAGE_TAG=$(echo "${{ needs.build-backend.outputs.imageTag }}" | head -1)
          CONTAINER_APP_NAME="ca-truepulse-api-${{ needs.setup.outputs.environment }}"
          
          az containerapp update \
            --name $CONTAINER_APP_NAME \
            --resource-group ${{ needs.infrastructure.outputs.resourceGroupName }} \
            --image $IMAGE_TAG

      - name: Wait for deployment
        run: |
          echo "Waiting for deployment to complete..."
          sleep 30
          
          CONTAINER_APP_NAME="ca-truepulse-api-${{ needs.setup.outputs.environment }}"
          
          # Check container app status
          STATUS=$(az containerapp show \
            --name $CONTAINER_APP_NAME \
            --resource-group ${{ needs.infrastructure.outputs.resourceGroupName }} \
            --query 'properties.runningStatus' -o tsv)
          
          if [ "$STATUS" != "Running" ]; then
            echo "Deployment may still be in progress. Status: $STATUS"
          fi
          
          echo "Deployment completed!"

      # Note: Health check via curl doesn't work for internal VNet deployments
      # Using Azure CLI to verify Container App status instead
      - name: Health check
        run: |
          CONTAINER_APP_NAME="ca-truepulse-api-${{ needs.setup.outputs.environment }}"
          RESOURCE_GROUP="${{ needs.infrastructure.outputs.resourceGroupName }}"
          
          for i in {1..10}; do
            STATUS=$(az containerapp show \
              --name $CONTAINER_APP_NAME \
              --resource-group $RESOURCE_GROUP \
              --query "properties.runningStatus" -o tsv 2>/dev/null || echo "Unknown")
            
            PROVISIONING=$(az containerapp show \
              --name $CONTAINER_APP_NAME \
              --resource-group $RESOURCE_GROUP \
              --query "properties.provisioningState" -o tsv 2>/dev/null || echo "Unknown")
            
            echo "Attempt $i: Running status: $STATUS, Provisioning state: $PROVISIONING"
            
            if [ "$STATUS" == "Running" ] && [ "$PROVISIONING" == "Succeeded" ]; then
              echo "âœ“ Health check passed! Container App is running."
              exit 0
            fi
            
            echo "  Retrying in 10s..."
            sleep 10
          done
          
          echo "Health check failed after 10 attempts"
          exit 1

  # ============================================================================
  # Build and Deploy Frontend
  # ============================================================================
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [setup, infrastructure, deploy-backend]
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: src/frontend/package-lock.json

      - name: Install dependencies
        working-directory: src/frontend
        run: npm ci

      - name: Build frontend
        working-directory: src/frontend
        env:
          NEXT_PUBLIC_API_URL: https://${{ needs.infrastructure.outputs.apiFqdn }}
          NEXT_PUBLIC_APP_ENV: ${{ needs.setup.outputs.environment }}
        run: npm run build

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get SWA deployment token
        id: swa-token
        run: |
          SWA_NAME=$(az resource list \
            --resource-group ${{ needs.infrastructure.outputs.resourceGroupName }} \
            --resource-type Microsoft.Web/staticSites \
            --query '[0].name' -o tsv)
          
          TOKEN=$(az staticwebapp secrets list \
            --name $SWA_NAME \
            --resource-group ${{ needs.infrastructure.outputs.resourceGroupName }} \
            --query 'properties.apiKey' -o tsv)
          
          echo "token=$TOKEN" >> $GITHUB_OUTPUT

      - name: Deploy to Static Web App
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ steps.swa-token.outputs.token }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: upload
          app_location: src/frontend
          output_location: out
          skip_app_build: true

  # ============================================================================
  # Deployment Complete
  # ============================================================================
  deployment-complete:
    name: Deployment Complete
    runs-on: ubuntu-latest
    needs: [setup, infrastructure, deploy-backend, deploy-frontend]
    if: success()
    steps:
      - name: Deployment Summary
        run: |
          echo "## Deployment Complete! ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### URLs" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend:** https://${{ needs.infrastructure.outputs.swaHostname }}" >> $GITHUB_STEP_SUMMARY
          echo "- **API:** https://${{ needs.infrastructure.outputs.apiFqdn }}" >> $GITHUB_STEP_SUMMARY
